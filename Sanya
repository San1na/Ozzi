local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib(".", "Synapse")

-- MAIN
local Main = Window:NewTab("Home")
local MainSection = Main:NewSection("Main")

MainSection:NewKeybind("Turn on-off", ".", Enum.KeyCode.Y, function()
    Library:ToggleUI()
end)

local isRolling = false  -- This variable will control the rolling state

-- Toggle for starting and stopping the rolling action
MainSection:NewToggle("AutoRoll", "just rolling", function(state)
    isRolling = state  -- Set rolling state based on toggle

    if isRolling then
        -- Start the rolling loop
        while isRolling do
            game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Eggs_Roll"):InvokeServer()
            wait(0.5)  -- Delay of 0.5 seconds
        end
    end
end)

-- Функции для покупок
local function purchaseStandardMerchant()
    for i = 1, 6 do
        local args = { [1] = "StandardMerchant", [2] = i }
        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("CustomMerchants_Purchase"):InvokeServer(unpack(args))
    end
end

MainSection:NewToggle("Autobuy Standard Merchant", "Automatically buy from Standard Merchant", function(state)
    _G.AutoBuyStandardMerchant = state

    if state then
        spawn(function()
            while _G.AutoBuyStandardMerchant do
                purchaseStandardMerchant()
                wait(0.35) -- Интервал между покупками
            end
        end)
    end
end)

local function purchasePotionVendingMachine()
    local args = { [1] = "PotionVendingMachine" }
    game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("VendingMachines_Purchase"):InvokeServer(unpack(args))
end

MainSection:NewToggle("Autobuy Potion Vending Machine", "Automatically buy from Potion Vending Machine", function(state)
    _G.AutoBuyPotionVendingMachine = state

    if state then
        spawn(function()
            while _G.AutoBuyPotionVendingMachine do
                purchasePotionVendingMachine()
                wait(0.35)
            end
        end)
    end
end)

local Boss42 = Window:NewTab("Other")
local Boss42Section = Boss42:NewSection(".")

Boss42Section:NewButton("ServerHop", "", function()
        local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local PlaceId = game.PlaceId

local function serverHop()
    -- Получаем список доступных серверов
    local servers = {}
    local cursor = nil
    local url = "https://games.roblox.com/v1/games/" .. PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
    
    repeat
        local response = game:HttpGet(cursor and (url .. "&cursor=" .. cursor) or url)
        local data = game:GetService("HttpService"):JSONDecode(response)
        
        for _, server in pairs(data.data) do
            if server.playing < server.maxPlayers then
                table.insert(servers, server.id)
            end
        end
        
        cursor = data.nextPageCursor
    until not cursor or #servers > 0

    if #servers > 0 then
        -- Переносим игрока на случайный сервер
        local randomServer = servers[math.random(1, #servers)]
        TeleportService:TeleportToPlaceInstance(PlaceId, randomServer, Players.LocalPlayer)
    else
        print(".")
    end
end

-- Вызов функции
serverHop()
end)

Boss42Section:NewButton("Anti afk", "ButtonInfo", function()
        repeat wait() until game:IsLoaded() and game.Players and game.Players.LocalPlayer and game.Players.LocalPlayer.Character

if getgenv().AntiAfkExecuted and thisoneissocoldww then 
    getgenv().AntiAfkExecuted = false
	getgenv().zamanbaslaticisi = false
	game.CoreGui.thisoneissocoldww:Destroy()
end

getgenv().AntiAfkExecuted = true

local thisoneissocoldww = Instance.new("ScreenGui")
local madebybloodofbatus = Instance.new("Frame")
local UICornerw = Instance.new("UICorner")
local DestroyButton = Instance.new("TextButton")
local uselesslabelone = Instance.new("TextLabel")
local timerlabel = Instance.new("TextLabel")
local uselesslabeltwo = Instance.new("TextLabel")
local fpslabel = Instance.new("TextLabel")
local uselesslabelthree = Instance.new("TextLabel")
local pinglabel = Instance.new("TextLabel")
local uselessframeone = Instance.new("Frame")
local UICornerww = Instance.new("UICorner")
local uselesslabelfour = Instance.new("TextLabel")

--Properties:

thisoneissocoldww.Name = "thisoneissocoldww"
thisoneissocoldww.Parent = game.CoreGui
thisoneissocoldww.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

madebybloodofbatus.Name = "madebybloodofbatus"
madebybloodofbatus.Parent = thisoneissocoldww
madebybloodofbatus.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
madebybloodofbatus.Position = UDim2.new(0.0854133144, 0, 0.13128835, 0)
madebybloodofbatus.Size = UDim2.new(0, 225, 0, 96)

UICornerw.Name = "UICornerw"
UICornerw.Parent = madebybloodofbatus

DestroyButton.Name = "DestroyButton"
DestroyButton.Parent = madebybloodofbatus
DestroyButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
DestroyButton.BackgroundTransparency = 1.000
DestroyButton.Position = UDim2.new(0.871702373, 0, 0.0245379955, 0)
DestroyButton.Size = UDim2.new(0, 27, 0, 15)
DestroyButton.Font = Enum.Font.SourceSans
DestroyButton.Text = "X"
DestroyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DestroyButton.TextSize = 14.000

DestroyButton.MouseButton1Click:connect(function()
	getgenv().AntiAfkExecuted = false
	
	wait(0.1)
	thisoneissocoldww:Destroy()
end)

uselesslabelone.Name = "uselesslabelone"
uselesslabelone.Parent = madebybloodofbatus
uselesslabelone.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
uselesslabelone.BackgroundTransparency = 1.000
uselesslabelone.Position = UDim2.new(0.302473009, 0, 0, 0)
uselesslabelone.Size = UDim2.new(0, 95, 0, 24)
uselesslabelone.Font = Enum.Font.SourceSans
uselesslabelone.Text = "Anti Afk By titela42"
uselesslabelone.TextColor3 = Color3.fromRGB(255, 255, 255)
uselesslabelone.TextSize = 14.000

timerlabel.Name = "timerlabel"
timerlabel.Parent = madebybloodofbatus
timerlabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
timerlabel.BackgroundTransparency = 1.000
timerlabel.Position = UDim2.new(0.65344125, 0, 0.68194294, 0)
timerlabel.Size = UDim2.new(0, 60, 0, 24)
timerlabel.Font = Enum.Font.SourceSans
timerlabel.Text = "0:0:0"
timerlabel.TextColor3 = Color3.fromRGB(255, 255, 255)
timerlabel.TextSize = 14.000

uselesslabeltwo.Name = "uselesslabeltwo"
uselesslabeltwo.Parent = madebybloodofbatus
uselesslabeltwo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
uselesslabeltwo.BackgroundTransparency = 1.000
uselesslabeltwo.Position = UDim2.new(0.038864471, 0, 0.373806685, 0)
uselesslabeltwo.Size = UDim2.new(0, 29, 0, 24)
uselesslabeltwo.Font = Enum.Font.SourceSans
uselesslabeltwo.Text = "Ping: "
uselesslabeltwo.TextColor3 = Color3.fromRGB(255, 255, 255)
uselesslabeltwo.TextSize = 14.000

fpslabel.Name = "fpslabel"
fpslabel.Parent = madebybloodofbatus
fpslabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
fpslabel.BackgroundTransparency = 1.000
fpslabel.Position = UDim2.new(0.724226236, 0, 0.358796299, 0)
fpslabel.Size = UDim2.new(0, 55, 0, 24)
fpslabel.Font = Enum.Font.SourceSans
fpslabel.Text = "this contact dev"
fpslabel.TextColor3 = Color3.fromRGB(255, 255, 255)
fpslabel.TextSize = 14.000

uselesslabelthree.Name = "uselesslabelthree"
uselesslabelthree.Parent = madebybloodofbatus
uselesslabelthree.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
uselesslabelthree.BackgroundTransparency = 1.000
uselesslabelthree.Position = UDim2.new(0.506917477, 0, 0.352585167, 0)
uselesslabelthree.Size = UDim2.new(0, 26, 0, 24)
uselesslabelthree.Font = Enum.Font.SourceSans
uselesslabelthree.Text = "Fps: "
uselesslabelthree.TextColor3 = Color3.fromRGB(255, 255, 255)
uselesslabelthree.TextSize = 14.000

pinglabel.Name = "pinglabel"
pinglabel.Parent = madebybloodofbatus
pinglabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
pinglabel.BackgroundTransparency = 1.000
pinglabel.Position = UDim2.new(0.20330891, 0, 0.371578127, 0)
pinglabel.Size = UDim2.new(0, 55, 0, 24)
pinglabel.Font = Enum.Font.SourceSans
pinglabel.Text = "if you see this"
pinglabel.TextColor3 = Color3.fromRGB(255, 255, 255)
pinglabel.TextSize = 14.000
pinglabel.TextWrapped = true

uselessframeone.Name = "uselessframeone"
uselessframeone.Parent = madebybloodofbatus
uselessframeone.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
uselessframeone.Position = UDim2.new(0.00444444455, 0, 0.243312627, 0)
uselessframeone.Size = UDim2.new(0, 224, 0, 5)

UICornerww.CornerRadius = UDim.new(0, 50)
UICornerww.Name = "UICornerww"
UICornerww.Parent = uselessframeone

uselesslabelfour.Name = "uselesslabelfour"
uselesslabelfour.Parent = madebybloodofbatus
uselesslabelfour.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
uselesslabelfour.BackgroundTransparency = 1.000
uselesslabelfour.Position = UDim2.new(0.0580285639, 0, 0.8125, 0)
uselesslabelfour.Size = UDim2.new(0, 95, 0, 12)
uselesslabelfour.Font = Enum.Font.SourceSans
uselesslabelfour.Text = "Anti-Afk Auto Enabled"
uselesslabelfour.TextColor3 = Color3.fromRGB(255, 255, 255)
uselesslabelfour.TextSize = 14.000



local Drag = game.CoreGui.thisoneissocoldww.madebybloodofbatus
gsCoreGui = game:GetService("CoreGui")
gsTween = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local dragging
local dragInput
local dragStart
local startPos
local function update(input)
	local delta = input.Position - dragStart
	local dragTime = 0.04
	local SmoothDrag = {}
	SmoothDrag.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	local dragSmoothFunction = gsTween:Create(Drag, TweenInfo.new(dragTime, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), SmoothDrag)
	dragSmoothFunction:Play()
end
Drag.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = Drag.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)
Drag.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging and Drag.Size then
		update(input)
	end
end)



local bbbatusxxxddddd = game:service'VirtualUser'

game:service'Players'.LocalPlayer.Idled:connect(function()
	bbbatusxxxddddd:CaptureController()
	bbbatusxxxddddd:ClickButton2(Vector2.new())
end)




local FPSsLabel = fpslabel
local RunService = game:GetService("RunService")
local RenderStepped = RunService.RenderStepped
local sec = nil
local FPS = {}

local function fre()
	local fr = tick()
	for index = #FPS,1,-1 do
		FPS[index + 1] = (FPS[index] >= fr - 1) and FPS[index] or nil
	end
	FPS[1] = fr
	local fps = (tick() - sec >= 1 and #FPS) or (#FPS / (tick() - sec))
	fps = math.floor(fps)
	fpslabel.Text = fps
end


sec = tick()
RenderStepped:Connect(fre)




spawn(function()
	repeat
		wait(1)
		local ping = tonumber(game:GetService("Stats"):FindFirstChild("PerformanceStats").Ping:GetValue())
		ping = math.floor(ping)
		pinglabel.Text = ping



	until pinglabel == nil
end)

local saniye = 0



local dakika = 0



local saat = 0




getgenv().zamanbaslaticisi = true

while true do


		if getgenv().zamanbaslaticisi then

			saniye = saniye + 1

			wait(1)

		end --if zaman baslaticisi end


		if saniye >= 60 then
			saniye = 0
			dakika = dakika + 1

		end --if saniye 60 end


		if dakika >= 60 then
			dakika = 0
			saat = saat + 1

		end --if dakika 60 end

		timerlabel.Text = saat..":"..dakika..":"..saniye
	end
end)


local CurrentFPS = 60

-- Функция для изменения FPS
local function ChangeFPS(value)
    CurrentFPS = value
    setfflag("TaskSchedulerTargetFps", tostring(value))
    print("FPS limit set to:", value)
end

Boss42Section:NewSlider("FPS Limit", "Adjust the maximum FPS", 144, 15, function(value) 
    ChangeFPS(value)
end)

local Fish42 = Window:NewTab("Fishing")
local Fish42Section = Fish42:NewSection(".")

local padGlow = workspace.MAP.INTERACT.FishingPads.Default.PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end


-- Переключатель для увеличения объекта в 100 раз
Fish42Section:NewToggle("Normal Fishing", ".", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.FishingPads.Corrupted.PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end


-- Переключатель для увеличения объекта в 100 раз
Fish42Section:NewToggle("Corrupted Fishing", ".", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.FishingPads.Ice.PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
Fish42Section:NewToggle("Ice Fishing", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local function purchaseFishingMerchant()
    for i = 1, 6 do
        local args = { [1] = "FishingMerchant", [2] = i }
        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("CustomMerchants_Purchase"):InvokeServer(unpack(args))
    end
end

Fish42Section:NewToggle("Autobuy Fishing Merchant", "Automatically buy from Fishing Merchant", function(state)
    _G.AutoBuyFishingMerchant = state

    if state then
        spawn(function()
            while _G.AutoBuyFishingMerchant do
                purchaseFishingMerchant()
                wait(0.35)
            end
        end)
    end
end)

local function purchaseIceFishingMerchant()
    for i = 1, 6 do
        local args = { [1] = "IceFishingMerchant", [2] = i }
        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("CustomMerchants_Purchase"):InvokeServer(unpack(args))
    end
end

Fish42Section:NewToggle("Autobuy Ice Fishing Merchant", "Automatically buy from Ice Fishing Merchant", function(state)
    _G.AutoBuyIceFishingMerchant = state

    if state then
        spawn(function()
            while _G.AutoBuyIceFishingMerchant do
                purchaseIceFishingMerchant()
                wait(0.35)
            end
        end)
    end
end)

local Mining = Window:NewTab("Mining")
local MiningSection = Mining:NewSection(".")

local padGlow = workspace.MAP.INTERACT.MiningPads["Dirt Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Dirt Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Stone Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Stone Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Bronze Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Bronze Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Iron Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Iron Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Gold Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Gold Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Emerald Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Emerald Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Obsidian Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Obsidian Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local padGlow = workspace.MAP.INTERACT.MiningPads["Runic Ore"].PadGlow

-- Сохраняем исходные значения размера и позиции объекта
local originalSize = padGlow.Size
local originalPosition = padGlow.Position

-- Функция для увеличения объекта в 100 раз по осям X и Z, но оставляем ось Y неизменной
local function enlargeByFactorXAndZ(factor)
    -- Увеличиваем только оси X и Z, ось Y остается прежней
    padGlow.Size = Vector3.new(padGlow.Size.X * factor, padGlow.Size.Y, padGlow.Size.Z * factor)
    
    -- Устанавливаем объект в нужную позицию (можно изменить)
    padGlow.Position = Vector3.new(0, padGlow.Position.Y, 0)  -- Это можно изменить на нужные координаты

    -- Убедимся, что объект закреплен
    padGlow.Anchored = true

    -- Отключаем коллизию, если нужно
    padGlow.CanCollide = false
end

-- Функция для восстановления исходного размера и позиции объекта
local function resetObject()
    padGlow.Size = originalSize
    padGlow.Position = originalPosition
end

-- Переключатель для увеличения объекта в 100 раз
MiningSection:NewToggle("Runic Ore", "", function(state)
    if state then
        print(".")
        enlargeByFactorXAndZ(100)  -- Увеличиваем объект в 100 раз по осям X и Z
    else
        print(".")
        resetObject()  -- Возвращаем объект к исходному размеру и позиции
    end
end)

local isAutoMerchantEnabled = false

-- Переменная для отслеживания состояния
local isAutoMerchantEnabled = false

-- Функция для выполнения покупки
local function performPurchase()
    while isAutoMerchantEnabled do
        -- Проверяем наличие всех необходимых объектов
        local replicatedStorage = game:GetService("ReplicatedStorage")
        local network = replicatedStorage:FindFirstChild("Network")
        if network then
            local customMerchant = network:FindFirstChild("CustomMerchants_Purchase")
            if customMerchant then
                for i = 1, 8 do -- Цикл с 1 до 7
                    local args = {
                        [1] = "MiningMerchant",
                        [2] = i, -- Индекс покупки
                    }

                    -- Выполняем покупку с использованием pcall для отлова ошибок
                    local success, err = pcall(function()
                        customMerchant:InvokeServer(unpack(args))
                    end)

                    if not success then
                        warn("Ошибка при выполнении InvokeServer: " .. tostring(err))
                    end

                    -- Задержка между покупками
                    wait(0.35) -- Уменьшил задержку для ускорения, если сервер позволяет
                end
            else
                warn("Не найден объект CustomMerchants_Purchase")
                break
            end
        else
            warn("Не найден объект Network в ReplicatedStorage")
            break
        end

        -- Дополнительная задержка между циклами покупок (если нужно)
        wait(0.35)
    end
end

-- Обработчик переключателя
MiningSection:NewToggle("Autobuy Mining Merchant", "", function(state)
    isAutoMerchantEnabled = state
    if state then
        -- Запускаем выполнение покупок
        performPurchase()
    end
end)

local Tech = Window:NewTab("Tech")
local TechSection = Tech:NewSection(".")

local toggleState = false -- Переменная для хранения состояния переключателя

TechSection:NewToggle("Roll(tech)", ".", function(state)
    toggleState = state -- Изменение состояния переключателя

    if toggleState then
        -- Если переключатель включен, запускаем цикл
        spawn(function()
            while toggleState do
                game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Tycoons: Hatch"):InvokeServer()
                wait(0.5) -- Задержка между выполнением (например, 1 секунда)
            end
        end)
    end
end)

TechSection:NewToggle("AutoBuy Tech Merchant", "Включить/выключить", function(state)
    toggleState = state -- Обновляем состояние переключателя

    while toggleState do
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Network = ReplicatedStorage:WaitForChild("Network")
        local PurchaseEvent = Network:WaitForChild("CustomMerchants_Purchase")

        for i = 1, 6 do
            local args = {
                "FactoryMerchant",
                i
            }
            PurchaseEvent:InvokeServer(unpack(args))
        end

        wait(0.35) -- Задержка между выполнениями, чтобы избежать перегрузки
    end
end)
